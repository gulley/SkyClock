
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Sky Clock calculations</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-04-07"><meta name="DC.source" content="calculations.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Sky Clock calculations</h1><!--introduction--><p>I look up at the sky just after sunset and I see an especially bright star. It's probably a planet. But which one? This sort of question gives me a good opportunity to play around with MATLAB. Let's do a visualization that shows where the planets are relative to the earth and the sun.</p><p><img vspace="5" hspace="5" src="../explanation1.png" alt=""> </p><p>Here is the basic grade-school illustration of the solar system, the one that shows the planets rolling around the Sun like peas on a plate. For simplicity, we're just showing the sun, the earth, the moon, Venus, and Mars. Viewed from far above the sun, it looks something like this.</p><p><img vspace="5" hspace="5" src="../explanation2.png" alt=""> </p><p>But we don't really have the luxury of this high-level view. Instead, we see little bright spots on a dark background somewhere "up there." Let's reduce our problem to determining what direction the planets are in. This leads to an image like this.</p><p><img vspace="5" hspace="5" src="../explanation3.png" alt=""> </p><p>Our goal is to make an accurate up-to-date version of this diagram. Specifically, in the plane of the ecliptic, and relative rto the sun, where should we look to find the moon and the naked-eye planets (Mercury, Venus, Mars, Jupiter, and Saturn)? To do this, we need to solve a few problems.</p><div><ul><li>Where are the planets?</li><li>Find the vector pointing from earth to each planet</li><li>Squash all these vectors into a single plane</li><li>Visualize the resulting disk</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Where Are the Planets?</a></li><li><a href="#2">Parse the data</a></li><li><a href="#5">Aerospace Toolbox Ephemeris</a></li><li><a href="#6">Build the Solar System Structure</a></li><li><a href="#7">Plot the planets</a></li><li><a href="#13">Plot the result</a></li></ul></div><h2>Where Are the Planets?<a name="1"></a></h2><p>First of all, where are the planets? There's a free JSON service for just about everything these days. Here's one that I've found for planetary data is hosted on Davy Wybiral's sitt here:</p><p><a href="http://davywybiral.blogspot.com/2011/11/planetary-states-api.html">http://davywybiral.blogspot.com/2011/11/planetary-states-api.html</a></p><pre class="codeinput">url = <span class="string">'http://www.astro-phys.com/api/de406/states?bodies=sun,moon,mercury,venus,earth,mars,jupiter,saturn'</span>;
json = urlread(url);
</pre><h2>Parse the data<a name="2"></a></h2><p>Now we can use <a href="http://www.mathworks.com/matlabcentral/fileexchange/42236-parse-json-text">Joe Hicklin's JSON parser</a> from the File Exchange. It returns a well-bahaved MATLAB structure.</p><pre class="codeinput">data = JSON.parse(json)
</pre><pre class="codeoutput">
data = 

       date: 2.4568e+06
    results: [1x1 struct]
       unit: 'km'

</pre><pre class="codeinput">data.results
</pre><pre class="codeoutput">
ans = 

    mercury: [1x6 double]
        sun: [2.3185e+05 -2.6852e+05 -1.3372e+05 825.5786 456.7942 177.1263]
       moon: [1x6 double]
    jupiter: [1x6 double]
       mars: [1x6 double]
      earth: [1x6 double]
      venus: [1x6 double]
     saturn: [1x6 double]

</pre><p>The distances are in kilometers, and I'm not even sure how this representation is oriented relative to the surrounding galaxy. But it doesn't really matter, because all I care about is the relative positions of the bodies in question.</p><h2>Aerospace Toolbox Ephemeris<a name="5"></a></h2><p>Note: We can also use the Aerospace Toolbox to get the same information.</p><p><tt>[pos,vel] = planetEphemeris(juliandate(now),'Sun','Earth')</tt></p><h2>Build the Solar System Structure<a name="6"></a></h2><pre class="codeinput"><span class="comment">% List of bodies we care about</span>
ssList = {<span class="string">'sun'</span>,<span class="string">'moon'</span>,<span class="string">'mercury'</span>,<span class="string">'venus'</span>,<span class="string">'earth'</span>,<span class="string">'mars'</span>,<span class="string">'jupiter'</span>,<span class="string">'saturn'</span>};

ss = [];
<span class="keyword">for</span> i = 1:length(ssList)
    ssObjectName = ssList{i};
    ss(i).name = ssObjectName;
    ssVec = data.results.(ssObjectName);
    ss(i).position = ssVec(1:3);
<span class="keyword">end</span>
ss
</pre><pre class="codeoutput">
ss = 

1x8 struct array with fields:

    name
    position

</pre><h2>Plot the planets<a name="7"></a></h2><pre class="codeinput">clf
<span class="keyword">for</span> i = 1:length(ss)
    p = ss(i).position;
    plot3(p(1),p(2),p(3),<span class="string">'r.'</span>);

    text(p(1),p(2),p(3),[<span class="string">' '</span> ss(i).name]);
    hold <span class="string">on</span>
<span class="keyword">end</span>

hold <span class="string">off</span>
axis <span class="string">equal</span>
</pre><img vspace="5" hspace="5" src="calculations_01.png" alt=""> <p>This is accurate, but not yet very helpful. As we said earlier, from our point of view here on the ground, the sun DOES go around the earth, as do the moon and all the planets.</p><p>Let's calculate the geocentric position vectors of each planet. To do this, we'll put the earth at the center of the system. Copernicus won't mind, because A) he's dead, and B) we admit this reference frame orbits the sun. That's no worry to us here since we're just looking at instantaneous positions in space.</p><p>We're also going to use another file from the File Exchange.  Georg Stillfried's <a href="http://www.mathworks.com/matlabcentral/fileexchange/25372">mArrow3</a></p><pre class="codeinput">addpath([fxpath(25372) filesep])

clf
pEarth = ss(5).position;
<span class="keyword">for</span> i = 1:length(ss)
    <span class="comment">% pe = position relative to earth</span>
    <span class="comment">% (i.e. a vector pointing from earth to body X)</span>
    pe = ss(i).position - pEarth;
    <span class="comment">% pne = normalized position relative to earth</span>
    pne = pe/sqrt(dot(pe,pe));
    ss(i).pne = pne;

    mArrow3([0 0 0],pne, <span class="keyword">...</span>
        <span class="string">'stemWidth'</span>,0.01,<span class="string">'FaceColor'</span>,[1 0 0]);

    text(pne(1),pne(2),pne(3),[<span class="string">' '</span> ss(i).name]);
    hold <span class="string">on</span>
<span class="keyword">end</span>
light
hold <span class="string">off</span>
axis <span class="string">equal</span>
axis <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="calculations_02.png" alt=""> <p>These are unit vectors pointing out from the center of the earth towards each of the other objects.</p><pre class="codeinput">view(-45,15)
</pre><img vspace="5" hspace="5" src="calculations_03.png" alt=""> <p>If we change our view point to look at the system edge-on, we can see the objects are not quie co-planar. For simplicity, let's squash them all into the same plane. We'll use the plane defined by the earth, moon, and sun.</p><pre class="codeinput"><span class="comment">% vsun is the unit vector that points from earth to sun</span>
<span class="comment">% vmoon is the unit vector that points from earth to moon</span>
<span class="comment">% The cross product of these two vectors will define the desired plane.</span>

psun = ss(1).pne;
pmoon = ss(2).pne;
psunXpmoon = cross(psun,pmoon);
mArrow3([0 0 0],psunXpmoon, <span class="keyword">...</span>
    <span class="string">'stemWidth'</span>,0.01,<span class="string">'FaceColor'</span>,[0 0 0]);
</pre><img vspace="5" hspace="5" src="calculations_04.png" alt=""> <p>You can see that some of the planets deviate from this plane. The planets stay close to the ecliptic, but they do wander a little. Now we project the vectors onto the plane defined by earth-moon-sun See <a href="http://en.wikipedia.org/wiki/Vector_projection">http://en.wikipedia.org/wiki/Vector_projection</a></p><pre class="codeinput">hold <span class="string">on</span>
<span class="keyword">for</span> i = 1:length(ss)
    pne = ss(i).pne;
    pneProj = pne - dot(pne,psunXpmoon)/dot(psunXpmoon,psunXpmoon)*psunXpmoon;
    ss(i).pneProj = pneProj;

    mArrow3([0 0 0],pneProj, <span class="keyword">...</span>
        <span class="string">'stemWidth'</span>,0.01,<span class="string">'FaceColor'</span>,[0 0 1]);
    text(pneProj(1),pneProj(2),pneProj(3),[<span class="string">' '</span> ss(i).name]);
<span class="keyword">end</span>
hold <span class="string">off</span>
axis <span class="string">equal</span>
</pre><img vspace="5" hspace="5" src="calculations_05.png" alt=""> <p>Calculate the angle between the sun and each of the bodies</p><p><img src="calculations_eq07863949619178080208.png" alt="$$ cos(\theta) =   $$"></p><pre class="codeinput">sun = ss(1).pneProj;
ss(1).theta = 0;

<span class="keyword">for</span> i = 1:length(ss)
    pneProj = ss(i).pneProj;
    cosTheta = dot(sun,pneProj)/(sqrt(dot(sun,sun))*sqrt(dot(pneProj,pneProj)));
    theta = acos(cosTheta);

    <span class="comment">% The sun-moon cross vector sticks out of the plane. We can use it to</span>
    <span class="comment">% determine the orientation of theta</span>

    x = cross(sun,pneProj);
    theta = theta*sign(dot(psunXpmoon,x));
    ss(i).theta = theta;

<span class="keyword">end</span>
</pre><h2>Plot the result<a name="13"></a></h2><pre class="codeinput">cla

k1 = 1.5;
k2 = 1.2;
<span class="keyword">for</span> i = 1:length(ss)
    beta = ss(i).theta + pi/2;
    x = cos(beta);
    y = sin(beta);
    mArrow3([0 0 0],[x y 0], <span class="keyword">...</span>
        <span class="string">'FaceColor'</span>,[0 0 1])
    line([0 k1*x],[0 k1*y],<span class="string">'Color'</span>,0.8*[1 1 1])
    text(k1*x,k1*y,ss(i).name,<span class="string">'HorizontalAlignment'</span>,<span class="string">'center'</span>)
<span class="keyword">end</span>
t = linspace(0,2*pi,100);
line(k2*cos(t),k2*sin(t),<span class="string">'Color'</span>,0.8*[1 1 1])
line(0,0,1,<span class="string">'Marker'</span>,<span class="string">'.'</span>,<span class="string">'MarkerSize'</span>,40,<span class="string">'Color'</span>,[0 0 1])

axis <span class="string">equal</span>
axis(2*[-1 1 -1 1])
<span class="comment">% set(gca,'XTick',[],'YTick',[])</span>
<span class="comment">% box on</span>
</pre><pre class="codeoutput">
ans = 

  Patch with properties:

    FaceColor: [0 0 1]
    FaceAlpha: 1
    EdgeColor: 'none'
    LineStyle: '-'
        Faces: [302x251 double]
     Vertices: [354x3 double]

  Use GET to show all properties


ans = 

  Patch with properties:

    FaceColor: [0 0 1]
    FaceAlpha: 1
    EdgeColor: 'none'
    LineStyle: '-'
        Faces: [302x251 double]
     Vertices: [354x3 double]

  Use GET to show all properties


ans = 

  Patch with properties:

    FaceColor: [0 0 1]
    FaceAlpha: 1
    EdgeColor: 'none'
    LineStyle: '-'
        Faces: [302x251 double]
     Vertices: [354x3 double]

  Use GET to show all properties


ans = 

  Patch with properties:

    FaceColor: [0 0 1]
    FaceAlpha: 1
    EdgeColor: 'none'
    LineStyle: '-'
        Faces: [302x251 double]
     Vertices: [354x3 double]

  Use GET to show all properties


ans = 

  Patch with properties:

    FaceColor: [0 0 1]
    FaceAlpha: 1
    EdgeColor: 'none'
    LineStyle: '-'
        Faces: [302x251 double]
     Vertices: [252x3 double]

  Use GET to show all properties


ans = 

  Patch with properties:

    FaceColor: [0 0 1]
    FaceAlpha: 1
    EdgeColor: 'none'
    LineStyle: '-'
        Faces: [302x251 double]
     Vertices: [354x3 double]

  Use GET to show all properties


ans = 

  Patch with properties:

    FaceColor: [0 0 1]
    FaceAlpha: 1
    EdgeColor: 'none'
    LineStyle: '-'
        Faces: [302x251 double]
     Vertices: [354x3 double]

  Use GET to show all properties


ans = 

  Patch with properties:

    FaceColor: [0 0 1]
    FaceAlpha: 1
    EdgeColor: 'none'
    LineStyle: '-'
        Faces: [302x251 double]
     Vertices: [354x3 double]

  Use GET to show all properties

</pre><img vspace="5" hspace="5" src="calculations_06.png" alt=""> <p>And there you have it: an accurate map of where the planets are in the sky for today's date.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Sky Clock calculations
%
% I look up at the sky just after sunset and I see an especially bright
% star. It's probably a planet. But which one? This sort of question gives
% me a good opportunity to play around with MATLAB. Let's do a
% visualization that shows where the planets are relative to the earth and
% the sun.
%
% <<../explanation1.png>>
%
% Here is the basic grade-school illustration of the solar system, the one
% that shows the planets rolling around the Sun like peas on a plate. For
% simplicity, we're just showing the sun, the earth, the moon, Venus, and
% Mars. Viewed from far above the sun, it looks something like this.
%
% <<../explanation2.png>>
%
% But we don't really have the luxury of this high-level view. Instead, we
% see little bright spots on a dark background somewhere "up there." Let's
% reduce our problem to determining what direction the planets are in. This
% leads to an image like this.
%
% <<../explanation3.png>>
%
% Our goal is to make an accurate up-to-date version of this diagram.
% Specifically, in the plane of the ecliptic, and relative rto the sun,
% where should we look to find the moon and the naked-eye planets (Mercury,
% Venus, Mars, Jupiter, and Saturn)? To do this, we need to solve a few
% problems.
%
% * Where are the planets?
% * Find the vector pointing from earth to each planet
% * Squash all these vectors into a single plane
% * Visualize the resulting disk

%% Where Are the Planets?
% First of all, where are the planets? There's a free JSON service for just
% about everything these days. Here's one that I've found for
% planetary data is hosted on Davy Wybiral's sitt here:
%
% <http://davywybiral.blogspot.com/2011/11/planetary-states-api.html>

url = 'http://www.astro-phys.com/api/de406/states?bodies=sun,moon,mercury,venus,earth,mars,jupiter,saturn';
json = urlread(url);

%% Parse the data
% Now we can use
% <http://www.mathworks.com/matlabcentral/fileexchange/42236-parse-json-text
% Joe Hicklin's JSON parser> from the File Exchange. It returns a
% well-bahaved MATLAB structure.

data = JSON.parse(json)

%%

data.results

%%
% The distances are in kilometers, and I'm not even sure how this
% representation is oriented relative to the surrounding galaxy. But it
% doesn't really matter, because all I care about is the relative positions
% of the bodies in question.

%% Aerospace Toolbox Ephemeris
% Note: We can also use the Aerospace Toolbox to get the same information.
%
% |[pos,vel] = planetEphemeris(juliandate(now),'Sun','Earth')|

%% Build the Solar System Structure

% List of bodies we care about
ssList = {'sun','moon','mercury','venus','earth','mars','jupiter','saturn'};

ss = [];
for i = 1:length(ssList)
    ssObjectName = ssList{i};
    ss(i).name = ssObjectName;
    ssVec = data.results.(ssObjectName);
    ss(i).position = ssVec(1:3);
end
ss

%% Plot the planets

clf
for i = 1:length(ss)
    p = ss(i).position;
    plot3(p(1),p(2),p(3),'r.');
    
    text(p(1),p(2),p(3),[' ' ss(i).name]);
    hold on
end

hold off
axis equal

%%
% This is accurate, but not yet very helpful. As we said earlier, from our
% point of view here on the ground, the sun DOES go around the earth, as do
% the moon and all the planets.
%
% Let's calculate the geocentric position vectors of each planet. To do
% this, we'll put the earth at the center of the system. Copernicus won't
% mind, because A) he's dead, and B) we admit this reference frame orbits
% the sun. That's no worry to us here since we're just looking at
% instantaneous positions in space.
%
% We're also going to use another file from the File Exchange.  Georg
% Stillfried's <http://www.mathworks.com/matlabcentral/fileexchange/25372
% mArrow3>

addpath([fxpath(25372) filesep])

clf
pEarth = ss(5).position;
for i = 1:length(ss)
    % pe = position relative to earth
    % (i.e. a vector pointing from earth to body X)
    pe = ss(i).position - pEarth;
    % pne = normalized position relative to earth
    pne = pe/sqrt(dot(pe,pe));
    ss(i).pne = pne;
    
    mArrow3([0 0 0],pne, ...
        'stemWidth',0.01,'FaceColor',[1 0 0]);
    
    text(pne(1),pne(2),pne(3),[' ' ss(i).name]);
    hold on
end
light
hold off
axis equal
axis off

%%
% These are unit vectors pointing out from the center of the earth towards
% each of the other objects.

view(-45,15)

%%
% If we change our view point to look at the system edge-on, we can see the
% objects are not quie co-planar. For simplicity, let's squash them all
% into the same plane. We'll use the plane defined by the earth, moon, and
% sun.

% vsun is the unit vector that points from earth to sun
% vmoon is the unit vector that points from earth to moon
% The cross product of these two vectors will define the desired plane.

psun = ss(1).pne;
pmoon = ss(2).pne;
psunXpmoon = cross(psun,pmoon);
mArrow3([0 0 0],psunXpmoon, ...
    'stemWidth',0.01,'FaceColor',[0 0 0]);

%%
% You can see that some of the planets deviate from this plane. The planets
% stay close to the ecliptic, but they do wander a little.
% Now we project the vectors onto the plane defined by earth-moon-sun
% See http://en.wikipedia.org/wiki/Vector_projection

hold on
for i = 1:length(ss)
    pne = ss(i).pne;
    pneProj = pne - dot(pne,psunXpmoon)/dot(psunXpmoon,psunXpmoon)*psunXpmoon;
    ss(i).pneProj = pneProj;
    
    mArrow3([0 0 0],pneProj, ...
        'stemWidth',0.01,'FaceColor',[0 0 1]);
    text(pneProj(1),pneProj(2),pneProj(3),[' ' ss(i).name]);
end
hold off
axis equal

%%
% Calculate the angle between the sun and each of the bodies
%
% $$ cos(\theta) =   $$

sun = ss(1).pneProj;
ss(1).theta = 0;

for i = 1:length(ss)
    pneProj = ss(i).pneProj;
    cosTheta = dot(sun,pneProj)/(sqrt(dot(sun,sun))*sqrt(dot(pneProj,pneProj)));
    theta = acos(cosTheta);
    
    % The sun-moon cross vector sticks out of the plane. We can use it to
    % determine the orientation of theta
    
    x = cross(sun,pneProj);
    theta = theta*sign(dot(psunXpmoon,x));
    ss(i).theta = theta;
    
end

%% Plot the result

cla

k1 = 1.5;
k2 = 1.2;
for i = 1:length(ss)
    beta = ss(i).theta + pi/2;
    x = cos(beta);
    y = sin(beta);
    mArrow3([0 0 0],[x y 0], ...
        'FaceColor',[0 0 1])
    line([0 k1*x],[0 k1*y],'Color',0.8*[1 1 1])
    text(k1*x,k1*y,ss(i).name,'HorizontalAlignment','center')
end
t = linspace(0,2*pi,100);
line(k2*cos(t),k2*sin(t),'Color',0.8*[1 1 1])
line(0,0,1,'Marker','.','MarkerSize',40,'Color',[0 0 1])

axis equal
axis(2*[-1 1 -1 1])
% set(gca,'XTick',[],'YTick',[])
% box on

%%
% And there you have it: an accurate map of where the planets are in the
% sky for today's date.



##### SOURCE END #####
--></body></html>